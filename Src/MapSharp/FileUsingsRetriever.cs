using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MapSharp;

internal static class FileUsingsRetriever
{
    /// <summary>
    /// Determines whether a syntax tree is autogenerated based on filename or header comments.
    /// </summary>
    /// <param name="syntaxTree">The syntax tree to evaluate.</param>
    /// <returns>True if the syntax tree is autogenerated; otherwise, false.</returns>
    private static bool IsGenerated(SyntaxTree syntaxTree)
    {
        var filePath = syntaxTree.FilePath;

        // Common autogenerated file name patterns
        if (!string.IsNullOrEmpty(filePath))
        {
            var lowerFilePath = filePath.ToLowerInvariant();
            if (lowerFilePath.EndsWith(".g.cs") ||
                lowerFilePath.EndsWith(".designer.cs") ||
                lowerFilePath.EndsWith(".generated.cs") ||
                lowerFilePath.Contains("/obj/") ||    // Exclude files in 'obj' directory
                lowerFilePath.Contains("/bin/"))       // Exclude files in 'bin' directory
            {
                return true;
            }
        }

        // Check for auto-generated comment at the top of the file
        var root = syntaxTree.GetRoot();
        var firstToken = root.GetFirstToken();

        if (firstToken.HasLeadingTrivia)
        {
            foreach (var trivia in firstToken.LeadingTrivia)
            {
                if (trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) ||
                    trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
                {
                    var comment = trivia.ToString().ToLowerInvariant();
                    if (comment.Contains("<auto-generated") || comment.Contains("<autogenerated"))
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Retrieves all using directives from the original source file where the specified class is declared.
    /// Excludes any usings from autogenerated files.
    /// </summary>
    /// <param name="classDeclaration">The class declaration syntax.</param>
    /// <returns>A list of using directive syntax nodes from the original file.</returns>
    public static List<string> GetOriginalFileUsings(ClassDeclarationSyntax classDeclaration)
    {
        // Access the syntax tree from the class declaration
        var syntaxTree = classDeclaration.SyntaxTree;

        // Skip if the syntax tree is autogenerated
        if (IsGenerated(syntaxTree))
        {
            return new List<string>(); // Return empty list
        }

        // Get the root node of the syntax tree as CompilationUnitSyntax
        var root = syntaxTree.GetRoot() as CompilationUnitSyntax;
        if (root == null)
        {
            return new List<string>(); // Return empty list if not a CompilationUnitSyntax
        }

        // Retrieve usings at the compilation unit level (outside any namespace)
        var classUsings =  root.Usings
            .Select(x => x.ToFullString())
            .Where(x => !x.Contains("MapSharp"))
            .ToList();
        
        //classUsings.Add($"using {GetNamespace(classDeclaration)};");

        return classUsings;
    }
    
    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        StringBuilder namespaceBuilder = new StringBuilder();
        SyntaxNode parent = classDeclaration.Parent;

        while (parent != null && !(parent is CompilationUnitSyntax))
        {
            if (parent is NamespaceDeclarationSyntax namespaceDecl)
            {
                // Handle traditional block-scoped namespaces
                var name = namespaceDecl.Name.ToString();
                if (namespaceBuilder.Length > 0)
                {
                    namespaceBuilder.Insert(0, ".");
                }
                namespaceBuilder.Insert(0, name);
            }
            else if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDecl)
            {
                // Handle file-scoped namespaces
                var name = fileScopedNamespaceDecl.Name.ToString();
                if (namespaceBuilder.Length > 0)
                {
                    namespaceBuilder.Insert(0, ".");
                }
                namespaceBuilder.Insert(0, name);
            }

            parent = parent.Parent;
        }

        return namespaceBuilder.ToString();
    }
}